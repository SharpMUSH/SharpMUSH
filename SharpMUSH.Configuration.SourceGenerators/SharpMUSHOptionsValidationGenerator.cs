using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SharpMUSH.Configuration.SourceGenerators;

[Generator]
public class SharpMUSHOptionsValidationGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var optionsProvider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (s, _) => s is RecordDeclarationSyntax { Identifier.Text: "SharpMUSHOptions" },
				transform: static (ctx, _) => (RecordDeclarationSyntax)ctx.Node)
			.Where(static m => m is not null);

		var compilation = context.CompilationProvider.Combine(optionsProvider.Collect());
		
		context.RegisterSourceOutput(compilation, Execute);
	}

	private static void Execute(SourceProductionContext spc, (Compilation Left, ImmutableArray<RecordDeclarationSyntax> Right) arg)
	{
		var compilation = arg.Left;
		var optionsClasses = arg.Right;

		var optionsClass = optionsClasses[0];
		var semanticModel = compilation.GetSemanticModel(optionsClass.SyntaxTree);
		var optionsSymbol = (INamedTypeSymbol)semanticModel.GetDeclaredSymbol(optionsClass)!;

		var sb = new StringBuilder();
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("using System.Text.RegularExpressions;");
		sb.AppendLine("using Microsoft.Extensions.Options;");
		sb.AppendLine("namespace SharpMUSH.Configuration.Generated;");
		sb.AppendLine();
		sb.AppendLine("public class ValidateSharpMUSHOptions : IValidateOptions<SharpMUSH.Configuration.Options.SharpMUSHOptions>");
		sb.AppendLine("{");
		sb.AppendLine("\tpublic ValidateOptionsResult Validate(string? name, SharpMUSH.Configuration.Options.SharpMUSHOptions options)");
		sb.AppendLine("\t{");

		foreach (var category in SelectCategoryProperties(optionsSymbol))
		{
			sb.AppendLine($"\r\t\t// Category: {category.Name}");
			sb.AppendLine($"\t\tvar {category.Name}Value = options.{category.Name};");
			foreach (var prop in SelectConfigProperties(category))
			{
				var attr = prop.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "SharpConfigAttribute");
				if (attr == null) continue;

				var pattern = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "ValidationPattern").Value.Value as string;
				if (string.IsNullOrEmpty(pattern)) continue;

				sb.AppendLine($"\t\tvar {prop.Name}Value = {category.Name}Value.{prop.Name};");
				sb.AppendLine($"\t\tif (!Regex.IsMatch({prop.Name}Value.ToString() ?? \"\", @\"{pattern}\"))");
				sb.AppendLine($"\t\t\treturn ValidateOptionsResult.Fail($\"Configuration option {category.Name}:{prop.Name} with value '{{{prop.Name}Value}}' is invalid.\");");
			}
		}

		sb.AppendLine("\t\treturn ValidateOptionsResult.Success;");
		sb.AppendLine("\t}");
		sb.AppendLine("}");

		spc.AddSource("ValidateSharpMUSHOptions_Generated.g.cs", sb.ToString());
	}

	private static IEnumerable<IPropertySymbol> SelectCategoryProperties(INamedTypeSymbol optionsSymbol)
	{
		return optionsSymbol.GetMembers().OfType<IPropertySymbol>().Where(x => x.Name is not "EqualityContract");
	}

	private static IEnumerable<IPropertySymbol> SelectConfigProperties(IPropertySymbol category)
	{
		if (category.Type is INamedTypeSymbol categoryType)
			return categoryType.GetMembers().OfType<IPropertySymbol>()
				.Where(p => p.GetAttributes().Any(a => a.AttributeClass?.Name == "SharpConfigAttribute"));
		return [];
	}
}