using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SharpMUSH.Configuration.SourceGenerators;

[Generator]
public class SharpMUSHOptionsValidationGenerator : IIncrementalGenerator
{
	private const string SHARPATTRIBUTE = "SharpConfigAttribute";
	
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var optionsProvider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (s, _) => s is RecordDeclarationSyntax { Identifier.Text: "SharpMUSHOptions" },
				transform: static (ctx, _) => (RecordDeclarationSyntax)ctx.Node)
			.Where(static m => m is not null);

		var compilation = context.CompilationProvider.Combine(optionsProvider.Collect());

		context.RegisterSourceOutput(compilation, Execute);
	}

	private static void Execute(SourceProductionContext spc,
		(Compilation Left, ImmutableArray<RecordDeclarationSyntax> Right) arg)
	{
		var compilation = arg.Left;
		var optionsClasses = arg.Right;

		var optionsClass = optionsClasses[0];
		var semanticModel = compilation.GetSemanticModel(optionsClass.SyntaxTree);
		var optionsSymbol = (INamedTypeSymbol)semanticModel.GetDeclaredSymbol(optionsClass)!;

		var sb = new StringBuilder();
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("using System.Text.RegularExpressions;");
		sb.AppendLine("using Microsoft.Extensions.Options;");
		sb.AppendLine("namespace SharpMUSH.Configuration.Generated;");
		sb.AppendLine();

		// Collect regex patterns and assign static fields
		var regexFields = new List<string>();
		var regexFieldNames = new Dictionary<string, string>();
		var regexIndex = 0;

		foreach (var prop in SelectCategoryProperties(optionsSymbol).SelectMany(SelectConfigProperties))
		{
			var attr = prop.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == SHARPATTRIBUTE);
			if (attr == null) continue;

			var pattern = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "ValidationPattern").Value.Value as string;
			if (string.IsNullOrEmpty(pattern) || regexFieldNames.ContainsKey(pattern!)) continue;

			var fieldName = $"_regex{regexIndex++}";
			regexFields.Add(
				$"\tprivate static readonly Regex {fieldName} = new Regex(@\"{pattern!}\", RegexOptions.Compiled);");
			regexFieldNames[pattern!] = fieldName;
		}

		sb.AppendLine(
			"public class ValidateSharpMUSHOptions : IValidateOptions<SharpMUSH.Configuration.Options.SharpMUSHOptions>");
		sb.AppendLine("{");
		// Emit regex fields
		foreach (var field in regexFields)
		{
			sb.AppendLine(field);
		}

		sb.AppendLine(
			"\tpublic ValidateOptionsResult Validate(string name, SharpMUSH.Configuration.Options.SharpMUSHOptions options)");
		sb.AppendLine("\t{");

		foreach (var category in SelectCategoryProperties(optionsSymbol))
		{
			sb.AppendLine($"\r\t\t// Category: {category.Name}");
			sb.AppendLine($"\t\tvar {category.Name}Value = options.{category.Name};");

			foreach (var prop in SelectConfigProperties(category))
			{
				var attr = prop.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == SHARPATTRIBUTE);
				if (attr == null) continue;

				var pattern = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "ValidationPattern").Value.Value as string;
				if (string.IsNullOrEmpty(pattern)) continue;

				var regexFieldName = regexFieldNames[pattern!];

				sb.AppendLine($"\t\tvar {prop.Name}Value = {category.Name}Value.{prop.Name};");
				sb.AppendLine($"\t\tif (!{regexFieldName}.IsMatch({prop.Name}Value.ToString() ?? \"\"))");
				sb.AppendLine(
					$"\t\t\treturn ValidateOptionsResult.Fail($\"Configuration option {category.Name}:{prop.Name} with value '{{{prop.Name}Value}}' is invalid.\");");
			}
		}

		sb.AppendLine("\t\treturn ValidateOptionsResult.Success;");
		sb.AppendLine("\t}");
		sb.AppendLine("}");

		spc.AddSource("ValidateSharpMUSHOptions_Generated.g.cs", sb.ToString());
	}

	private static IEnumerable<IPropertySymbol> SelectCategoryProperties(INamedTypeSymbol optionsSymbol)
		=> optionsSymbol.GetMembers().OfType<IPropertySymbol>().Where(x => x.Name is not "EqualityContract");

	private static IEnumerable<IPropertySymbol> SelectConfigProperties(IPropertySymbol category)
	{
		return category.Type is INamedTypeSymbol categoryType
			? categoryType
				.GetMembers()
				.OfType<IPropertySymbol>()
				.Where(p => p.GetAttributes().Any(a => a.AttributeClass?.Name == "SharpConfigAttribute"))
			: [];
	}
}