using System;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SharpMUSH.Implementation.Generated;

using FunctionInformation = (string Name, string ClassName, string MethodName, string AttributeName, string MinArgs, string MaxArgs, string Flags, string[] Restrict);

[Generator]
public sealed class SharpMUSHFunctionLibraryGenerator : IIncrementalGenerator
{
	private const string ATTRIBUTENAME = "SharpMUSH.Library.Attributes.SharpFunctionAttribute";
	
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var provider = context.SyntaxProvider.ForAttributeWithMetadataName(ATTRIBUTENAME,
				static (node, _) => node is MethodDeclarationSyntax,
				static (ctx, _) => (
					Method: (MethodDeclarationSyntax)ctx.TargetNode,
					Attribute: ctx.Attributes.First(a =>
						a.AttributeClass?.ToDisplayString() == ATTRIBUTENAME
					)
				))
			.Where(static x => x.Method is not null && x.Attribute is not null);

		var compilation = context.CompilationProvider.Combine(provider.Collect());

		context.RegisterSourceOutput(compilation, Execute);
	}

	private static FunctionInformation Transform(MethodDeclarationSyntax syntax, AttributeData attr)
	{
		var name = syntax.Identifier.Text;
		var className = Helper.GetFullClassName(syntax);
		var methodName = syntax.Identifier.Text;
		var attrName = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "Name").Value.Value?.ToString() ?? "";
		var minArgs = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "MinArgs").Value.Value?.ToString() ?? "0";
		var maxArgs = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "MaxArgs").Value.Value?.ToString() ?? "32";
		var flags = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "Flags").Value.Value?.ToString() ??
		            "FunctionFlags.Regular";
		var restrictArg = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "Restrict").Value;
		var restrict = restrictArg.Kind == TypedConstantKind.Array
			? restrictArg.Values.Select(v => v.Value?.ToString() ?? "").ToArray()
			: [];
		return (name, className, methodName, attrName, minArgs, maxArgs, flags, restrict);
	}

	private static void Execute(SourceProductionContext context,
		(Compilation Left, ImmutableArray<(MethodDeclarationSyntax Method, AttributeData Attribute)> list) tuple)
	{
		var list = tuple.list;
		var infoList = list.Select(item => Transform(item.Method, item.Attribute)).ToList();

		var code = $$"""
		             // Generated by SharpMUSHIncrementalGenerator
		             namespace SharpMUSH.Implementation.Generated; 
		             using System.Collections.Generic;

		             public static class FunctionLibrary 
		             {
		               private static SharpMUSH.Library.Definitions.FunctionDefinition CreateFunctionDefinition(SharpMUSH.Library.Attributes.SharpFunctionAttribute attr, Func<SharpMUSH.Library.ParserInterfaces.IMUSHCodeParser, SharpMUSH.Library.Attributes.SharpFunctionAttribute, ValueTask<SharpMUSH.Library.ParserInterfaces.CallState>> method)
		                 => new SharpMUSH.Library.Definitions.FunctionDefinition(attr, (parser) => method(parser, attr));

		               public static readonly Dictionary<string, SharpMUSH.Library.Definitions.FunctionDefinition> Functions = new Dictionary<string, SharpMUSH.Library.Definitions.FunctionDefinition>
		               {
		                 {{string.Join(",\n\t\t", infoList.Select(InfoToSource))}}
		               };
		             }
		             """;

		context.AddSource("SharpMUSH.Implementation.Generated.FunctionLibrary.g.cs", code);
	}

	private static string InfoToSource(FunctionInformation info)
	{
		return
			$$"""
			  { 
			  			"{{info.AttributeName}}", 
			  			CreateFunctionDefinition(
			  				new SharpMUSH.Library.Attributes.SharpFunctionAttribute 
			  				{
			  					Name = "{{info.AttributeName}}",
			  					MinArgs = {{info.MinArgs}},
			  					MaxArgs = {{info.MaxArgs}},
			  					Flags = (SharpMUSH.Library.Definitions.FunctionFlags){{info.Flags}},
			  					Restrict = [ {{string.Join(", ", info.Restrict.Select(x => $"\"{x}\""))}} ]
			  				},
			  				{{info.ClassName}}.{{info.MethodName}})
			  		}
			  """;
	}
}