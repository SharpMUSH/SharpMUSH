using System;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SharpMUSH.Implementation.Generated;

[Generator]
public sealed class SharpMUSHFunctionLibraryGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var provider = context.SyntaxProvider.ForAttributeWithMetadataName("SharpMUSH.Library.Attributes.SharpFunctionAttribute",
				(node, _) => node is MethodDeclarationSyntax,
				(ctx, _) => (MethodDeclarationSyntax)ctx.TargetNode)
			.Where(x => x is not null);

		var compilation = context.CompilationProvider.Combine(provider.Collect());
		
		context.RegisterSourceOutput(compilation, Execute);
	}

	private static string GetFullClassName(MethodDeclarationSyntax method)
	{
		var classNode = method.Parent as ClassDeclarationSyntax;
		if (classNode == null) throw new Exception("Method is not inside a class.");
		var ns = classNode.Parent;
		string? nsName = null;
		while (ns != null)
		{
			if (ns is NamespaceDeclarationSyntax nds)
			{
				nsName = nds.Name.ToString();
				break;
			}
			if (ns is FileScopedNamespaceDeclarationSyntax fnds)
			{
				nsName = fnds.Name.ToString();
				break;
			}
			ns = ns.Parent;
		}
		return nsName != null ? $"{nsName}.{classNode.Identifier.Text}" : classNode.Identifier.Text;
	}

	private void Execute(SourceProductionContext context, (Compilation Left, ImmutableArray<MethodDeclarationSyntax> list) tuple)
	{
		var list = tuple.list;
		var infoList = list.Select(syntax => new {
			Name = syntax.Identifier.Text,
			ClassName = GetFullClassName(syntax),
			MethodName = syntax.Identifier.Text
		}).ToList();

		var code = $$"""
				     // Generated by SharpMUSHIncrementalGenerator
				     namespace SharpMUSH.Implementation.Generated; 
				     
				     using System.Collections.Generic;
				     
				     public static class FunctionLibrary 
				     {
				       public static readonly Dictionary<string, SharpMUSH.Library.Definitions.FunctionDefinition> Test = new Dictionary<string, SharpMUSH.Library.Definitions.FunctionDefinition> 
				       {
				         {{string.Join(",\n\t", infoList.Select(info 
					         => $"{{ \"{info.Name}\", new SharpMUSH.Library.Definitions.FunctionDefinition(null,(x) => {info.ClassName}.{info.MethodName}(x,null)) }}"))}}
				       };
				     
				     	{{string.Join("\n\t", infoList.Select(info 
					      => $"public const string {info.Name} = \"{info.ClassName}.{info.MethodName}(parser, attributeInfo)\";"))}}
				     
				     	public static List<string> RegisteredFunctions = new List<string> 
				     	{ 
				     		{{string.Join(", \n\t\t", infoList.Select(info => $"\t\t\"{info.Name}\""))}}
				     	};
				     }
				     """;
		context.AddSource("SharpMUSH.Implementation.Generated.One.g.cs", code);
	}
}