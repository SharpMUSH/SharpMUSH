using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SharpMUSH.Implementation.Generated;

[Generator]
public sealed class SharpMUSHFunctionLibraryGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var provider = context.SyntaxProvider.ForAttributeWithMetadataName("SharpMUSH.Library.Attributes.SharpFunctionAttribute",
				(node, _) => node is MethodDeclarationSyntax,
				(ctx, _) => (MethodDeclarationSyntax)ctx.TargetNode)
			.Where(x => x is not null);

		var compilation = context.CompilationProvider.Combine(provider.Collect());
		
		context.RegisterSourceOutput(compilation, Execute);
	}

	private void Execute(SourceProductionContext context, (Compilation Left, ImmutableArray<MethodDeclarationSyntax> list) tuple)
	{
		var list = tuple.list;
		var nameList = list.Select(syntax => syntax.Identifier.Text).ToList();

		var code = $$"""
		             // Generated by SharpMUSHIncrementalGenerator
		             namespace SharpMUSH.Implementation.Generated; 
		             
		             // public class FunctionLibraryService2 : LibraryService<string, FunctionDefinition> { }
		             // Ensure it gets initialized ahead of time, and can provide all method calls.
		             // That way it can be used during Dependency Injection.

		             public static class FunctionLibrary 
		             { 
		             	{{string.Join("\n", nameList.Select(name => $"public const string {name} = \"{name}\";"))}}
		             	
		             	public static List<string> RegisteredFunctions = new List<string> 
		             	{ 
		             		{{string.Join(", ", nameList.Select(name => $"\t\t\"{name}\""))}}
		             	};
		             } 
		             """;
		
		context.AddSource("SharpMUSH.Implementation.Generated.One.g.cs", code);
	}
}