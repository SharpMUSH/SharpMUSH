using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;

namespace SharpMUSH.Configuration.Generated;

using PropertyMetadata = (string PropertyName, string AttributeName);

[Generator]
public class ConfigMetadataGenerator : IIncrementalGenerator
{
	private const string SHARPATTRIBUTE = "SharpConfigAttribute";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var optionsProvider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (s, _) => s is RecordDeclarationSyntax { Identifier.Text: "SharpMUSHOptions" },
				transform: static (ctx, _) => (RecordDeclarationSyntax)ctx.Node)
			.Where(static m => m is not null);

		var compilation = context.CompilationProvider.Combine(optionsProvider.Collect());

		context.RegisterSourceOutput(compilation, Execute);
	}

	private static void Execute(SourceProductionContext spc,
		(Compilation Left, ImmutableArray<RecordDeclarationSyntax> Right) arg)
	{
		var compilation = arg.Left;
		var optionsClasses = arg.Right;

		if (optionsClasses.Length == 0) return;

		var optionsClass = optionsClasses[0];
		var semanticModel = compilation.GetSemanticModel(optionsClass.SyntaxTree);
		var optionsSymbol = semanticModel.GetDeclaredSymbol(optionsClass) as INamedTypeSymbol;

		if (optionsSymbol == null) return;

		var metadata = GetPropertyMetadata(optionsSymbol).ToImmutableArray();
		var metadataWithAttributes = GetPropertyMetadataWithAttributes(optionsSymbol)
			.Select(GeneratePropertyMetadataEntry)
			.ToImmutableArray();

		var str = $$"""
		            // <autogenerated/>
		            using System.Collections.Generic;
		            using System.Collections.Immutable;
		            using SharpMUSH.Configuration.Options;
		            
		            namespace SharpMUSH.Configuration.Generated;
		            
		            public static class ConfigMetadata
		            {
		                public static readonly ImmutableDictionary<string, string> PropertyToAttributeName = new Dictionary<string, string>
		                {
		                    {{string.Join(",\n            ", metadata.Select(m => $"{{ \"{m.PropertyName}\", \"{m.AttributeName}\" }}"))}}
		                }.ToImmutableDictionary();
		                
		                public static readonly ImmutableDictionary<string, string> AttributeToPropertyName = new Dictionary<string, string>
		                {
		                    {{string.Join(",\n            ", metadata.Select(m => $"{{ \"{m.AttributeName}\", \"{m.PropertyName}\" }}"))}}
		                }.ToImmutableDictionary();
		                
		                public static readonly ImmutableDictionary<string, SharpConfigAttribute> PropertyMetadata = new Dictionary<string, SharpConfigAttribute>
		                {
		                    {{string.Join(",\n            ", metadataWithAttributes)}}
		                }.ToImmutableDictionary();
		            }
		            """;

		spc.AddSource("ConfigMetadata_Generated.g.cs", str);
	}

	private static IEnumerable<PropertyMetadata> GetPropertyMetadata(INamedTypeSymbol optionsSymbol)
	{
		foreach (var category in SelectCategoryProperties(optionsSymbol))
		{
			foreach (var prop in SelectConfigProperties(category))
			{
				var attr = prop.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == SHARPATTRIBUTE);
				var attrName = attr?.NamedArguments.FirstOrDefault(kv => kv.Key == "Name").Value.Value as string;
				yield return (prop.Name, attrName ?? prop.Name);
			}
		}
	}

	private static IEnumerable<(IPropertySymbol Property, AttributeData Attribute)> GetPropertyMetadataWithAttributes(INamedTypeSymbol optionsSymbol)
	{
		foreach (var category in SelectCategoryProperties(optionsSymbol))
		{
			var categoryName = category.Name;
			foreach (var prop in SelectConfigProperties(category))
			{
				var attr = prop.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == SHARPATTRIBUTE);
				if (attr is not null)
				{
					yield return (prop, attr);
				}
			}
		}
	}

	private static string GeneratePropertyMetadataEntry((IPropertySymbol Property, AttributeData Attribute) metadata)
	{
		var prop = metadata.Property;
		var attr = metadata.Attribute;

		// Get the category from the containing property symbol
		var category = "";
		if (prop.ContainingType is INamedTypeSymbol containingType)
		{
			// The property's containing type is the category record (e.g., AttributeOptions)
			category = containingType.Name;
		}

		var name = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "Name").Value.Value as string ?? "";
		var description = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "Description").Value.Value as string ?? "";
		var validationPattern = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "ValidationPattern").Value.Value as string;

		var validationPatternStr = validationPattern != null ? $"\"{EscapeString(validationPattern)}\"" : "null";
		var descriptionStr = !string.IsNullOrEmpty(description) ? $"\"{EscapeString(description)}\"" : "\"\"";

		return $"{{ \"{prop.Name}\", new SharpConfigAttribute {{ Name = \"{name}\", Description = {descriptionStr}, Category = \"{category}\", ValidationPattern = {validationPatternStr} }} }}";
	}

	private static string EscapeString(string str)
		=> str.Replace("\\", "\\\\").Replace("\"", "\\\"");

	private static IEnumerable<IPropertySymbol> SelectCategoryProperties(INamedTypeSymbol optionsSymbol)
		=> optionsSymbol.GetMembers().OfType<IPropertySymbol>().Where(x => x.Name is not "EqualityContract");

	private static IEnumerable<IPropertySymbol> SelectConfigProperties(IPropertySymbol category)
	{
		return category.Type is INamedTypeSymbol categoryType
			? categoryType
				.GetMembers()
				.OfType<IPropertySymbol>()
				.Where(p => p.GetAttributes().Any(a => a.AttributeClass?.Name == SHARPATTRIBUTE))
			: [];
	}
}
