using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection.Metadata;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SharpMUSH.Configuration.Generated;

using RegexFieldsAndNames = (string Field, string Pattern, string FieldName);

[Generator]
public class SharpMUSHOptionsValidationGenerator : IIncrementalGenerator
{
	private const string SHARPATTRIBUTE = "SharpConfigAttribute";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var optionsProvider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (s, _) => s is RecordDeclarationSyntax { Identifier.Text: "SharpMUSHOptions" },
				transform: static (ctx, _) => (RecordDeclarationSyntax)ctx.Node)
			.Where(static m => m is not null);

		var compilation = context.CompilationProvider.Combine(optionsProvider.Collect());

		context.RegisterSourceOutput(compilation, Execute);
	}

	private static void Execute(SourceProductionContext spc,
		(Compilation Left, ImmutableArray<RecordDeclarationSyntax> Right) arg)
	{
		var compilation = arg.Left;
		var optionsClasses = arg.Right;

		var optionsClass = optionsClasses[0];
		var semanticModel = compilation.GetSemanticModel(optionsClass.SyntaxTree);
		var optionsSymbol = semanticModel.GetDeclaredSymbol(optionsClass)!;
		var regexFieldsAndNames = GetRegexFieldsAndNames(optionsSymbol).ToImmutableArray();
		var regexFieldNames = regexFieldsAndNames.ToDictionary(x => x.Pattern, x => x.FieldName);

		var str =
			$$"""
			  // <autogenerated/>
			  using System.Text.RegularExpressions;
			  using Microsoft.Extensions.Options;
			  namespace SharpMUSH.Configuration.Generated;

			  public class ValidateSharpMUSHOptions : IValidateOptions<SharpMUSH.Configuration.Options.SharpMUSHOptions>
			  {
			    {{string.Join("\n  ", regexFieldsAndNames
				    .Select(x => x.Field))}}

			    public ValidateOptionsResult Validate(string name, SharpMUSH.Configuration.Options.SharpMUSHOptions options)
			    {
			  {{string.Join("\n\n", SelectCategoryProperties(optionsSymbol)
				      .Select(category => GetSourceForCategories(category, regexFieldNames)))}}
			      
			      return ValidateOptionsResult.Success;
			    }
			  }
			  """;

		spc.AddSource("ValidateSharpMUSHOptions_Generated.g.cs", str);
	}

	private static string GetSourceForCategories(IPropertySymbol category,
		Dictionary<string, string> regexFieldNames)
	{
		return $$"""
		              // Category: {{{category.Name}}}
		              var {{category.Name}}Value = options.{{category.Name}};
		              {{string.Join("\n\n", SelectConfigProperties(category)
			          .Select(prop => GetValidationBodyForProperty(prop, regexFieldNames, category))
			          .Where(x => !string.IsNullOrWhiteSpace(x))
		          )}}
		          """;
	}

	private static string? GetValidationBodyForProperty(IPropertySymbol prop, Dictionary<string, string> regexFieldNames,
		IPropertySymbol category)
	{
		var attr = prop.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == SHARPATTRIBUTE);
		if (attr == null) return null;

		var pattern = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "ValidationPattern").Value.Value as string;
		if (string.IsNullOrEmpty(pattern)) return null;

		var regexFieldName = regexFieldNames[pattern!];

		return
			$$"""
			      var {{prop.Name}}Value = {{category.Name}}Value.{{prop.Name}};
			      if (!{{regexFieldName}}.IsMatch({{prop.Name}}Value.ToString() ?? ""))
			      {
			        return ValidateOptionsResult.Fail($"Configuration option ({{category.Name}}) {{prop.Name}} with value '{{{prop.Name}}Value}' is invalid.");
			      }
			  """;
	}

	private static IEnumerable<RegexFieldsAndNames> GetRegexFieldsAndNames(INamedTypeSymbol optionsSymbol)
		=> SelectCategoryProperties(optionsSymbol)
			.SelectMany(SelectConfigProperties)
			.Select(prop =>
			{
				var attr = prop.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == SHARPATTRIBUTE);
				var pattern = attr?.NamedArguments.FirstOrDefault(kv => kv.Key == "ValidationPattern").Value.Value as string;
				return pattern;
			})
			.Where(pattern => !string.IsNullOrEmpty(pattern))
			.Distinct()
			.Select((pattern, idx) => (
				Field: $"private static readonly Regex _regex{idx} = new Regex(@\"{pattern!}\", RegexOptions.Compiled);",
				Pattern: pattern!,
				FieldName: $"_regex{idx}"
			));

	private static IEnumerable<IPropertySymbol> SelectCategoryProperties(INamedTypeSymbol optionsSymbol)
		=> optionsSymbol.GetMembers().OfType<IPropertySymbol>().Where(x => x.Name is not "EqualityContract");

	private static IEnumerable<IPropertySymbol> SelectConfigProperties(IPropertySymbol category)
	{
		return category.Type is INamedTypeSymbol categoryType
			? categoryType
				.GetMembers()
				.OfType<IPropertySymbol>()
				.Where(p => p.GetAttributes().Any(a => a.AttributeClass?.Name == "SharpConfigAttribute"))
			: [];
	}
}